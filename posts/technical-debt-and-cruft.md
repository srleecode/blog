---
title: Technical debt and cruft
description: A look at the differences between technical debt and cruft. The solutions for resolving them, why technical debt is natural and cruft should be avoided
tags: Software development
publishedDate: 4/3/2020
published: true
---

# Technical debt and cruft

As developers and software development teams, we must be vigilant to ensure that the quality of our code base remains high. The difficult aspect of doing this is that it requires teams to continually allocate some portion of their time to refactoring and improving the existing code. Like with entropy, technical debt naturally accrues over time and developers need to take some time to clean it up. This time can be hard to justify because the outcome of it isn't visible and it doesn't sound good to stakeholders, it doesn't introduce new functionality and its impact is only seen in the long term. In the short term, in fact, there is a cost to it as it takes time to write high quality code as seen in the below [graph](https://martinfowler.com/articles/is-quality-worth-cost.html).

<img class="nx-jangular-blog-centered-image" src="/assets/velocity-and-code-quality.png">

The impact of low quality code is insidious. It is not easily visible in the short term, but it accumulates. This is because low quality code is hard to understand and refactor and this makes it more likely for any new changes related to it to also be of low quality as the new code must workaround or work with the low-quality code.

When looking at code quality it is important to make a distinction between two separate, but related terms: [technical debt and cruft (poorly written code)](https://www.youtube.com/watch?v=pqeJFYwnkjE).

Technical debt is produced when you aim for rapid delivery, not the sake of meeting a deadline, but to elicit quick feedback which provides the data necessary to adjust the design to be more congruent with the actual needs. Technical debit is payed back through code refactoring as an understanding of the domain matures.

> Although immature code may work fine and be completely acceptable to the customer, excess quantities will make a program unmasterable, leading to extreme specialization of programmers and finally an inflexible product. ... A little debt speeds development so long as it is paid back promptly with a rewrite ... Every minute spent on not-quite-right code counts as interest on that debt. Entire engineering organizations can be brought to a stand-still under the debt load of an unconsolidated implementation - [Ward Cunningham](http://c2.com/doc/oopsla92.html)

Technical debt is different to poorly written code. For example, although legacy code is technical debt it was probably right for the time and could have been well written code. An important thing to realise is that all code accrues technical debt and becomes a growing burden over time (it must be understood and maintained from time to time). Code becomes technical debt as the domain changes, new technologies come out or your understanding of the domain improves.

Cruft, on the other hand, is primarily about code that was never good. Cruft is generated when you are aiming for rapid delivery, not to illicit feedback, but for the sake of meeting a deadline. Cruft is about sacrificing future productivity to improve short term productivity. It is generated by attempting to sacrifice quality to improve delivery time and would involve things like skipping unit testing, working in silos and making decisions on the fly about ambiguous requirements. High levels of cruft result from a dysfunction somewhere in either structure or process.

Cruft can be split into a few further different types as seen in the below [diagram](https://martinfowler.com/bliki/TechnicalDebtQuadrant.html). If we consider both cruft and technical debt to be types of debt, then prudence in regards to this debt is choosing to take on the debt after considering the current benefits versus the future costs. Being deliberate or inadvertent in regards to this debt would be whether you were aware that the code you were writing is cruft.

<img class="nx-jangular-blog-centered-image" src="/assets/cruft-technical-debt-quadrant.png">

Examples:

- Reckless and deliberate
  -  Culture where quality is given low priority - a common cause of this is outsourcing or getting someone to work on a project for a short period of time. This is often a problem because it causes people to have no emotional attachment to the project or its quality. Since they won't be involved with maintaining it they just want to get it done and move onto the next thing as quickly as possible.
- Reckless and inadvertent 
  - knowledge not being shared 
  - learning not being given value
  - decisions being made by the wrong people - this could be someone inexperienced being given the power to make decisions which they shouldn't. Another common cause is when top down decisions occur too often. People at the bottom of heirachies are often better suited to making a wide range of decisions, especially those that need to be done in a timely manner. This is primarily because they are closer to the information from which those decisions should be made. To neglect this is to essentially make your decisions based on information that is likely out of date and easily misunderstood as it must explicated from those at the bottom to those at the top.
  - not generating appropriate and useful feedback
- Prudent and deliberate cruft
  - under-priortisation of certain types of work, i.e not allocating the appropriate amount of rresources in accordance with the value something will bring when delivered. This is often because the value or costs of something is hard to see. This can happen when the value or costs are:
    - spread out over longe periods of time. An example is [testing](https://scottlee.netlify.com/concepts/regression-death-spiral) or more broadly a focus on quality 
    - small at the start, but able to scale or accumulate easily
    - asymetric. Complex domains have asymmetric payoffs as it is difficult to know beforehand which routes are worth pursuing or valuable. You have to explore them first to find out if they are valuable. This can be seen as wasteful and inefficient when the exploration turns out to not be fruitful. If a company is focused on efficiency and people pursuing potentially wasteful things is seen as detrimental or harmful, then it won't be done which will have massive impacts on innovation and will heavily reduce certain types of improvements.
    - complicated, technical or difficult to understand
  - not minimising work in progress (WIP) - Everyone is limited. They can only focus on a set amount of things for a set amount of time. When they move past these limits, focus is lost and quality begins to drop. High WIP means that you need to constantly be juggling multiple items at once. This causes focus to be lost and time to be lost as as you need to remember where you left off with each task in the rotation. The overall idea is that if you try to do too many things, the results will be lower in quality.
  - unneccesarry pressure or stress - this would be rushing to get a release out, but considering the costs involved with doing so and choosing to do it anyway. A team may know about good design practices, even be capable of practicing them, but decide to go "quick and dirty" because they think they can't afford the time required to write clean code. This often occurs due to management dysfunctions which lead to too much pressure being placed on developers to deliver code by a specific, often extremely rushed, deadline.
- prudent and inadvertent
  - learning - it would be following the best practices and writing high quality code, but through the process of writing the code learning a better way to design it. Programming is a process of learning. Therefore, inadvertently as we further develop code we find that the earlier code has become technical debt. 
  - New developments - tech debt occurs naturally when you exist in an improving environment. New updates and developments make older well written code tech debt. If tech debt is not acted on appropriately, then new code being added would be cruft as it doesn't align with the current best practices.

The concept of technical debt shows that even the best teams will have some debt to deal with as a project progresses. Debt. however, accrues over time, therefore, teams should be careful not to recklessly overload it with crummy code (cruft). Cruft should be minimised and to enable this developers should be:

- empowered and given time to ensure the quality of the code stays at high levels
- trained so that they know how to design well and write high quality code
- made aware of the importance of maintaining the quality of the code base and that it is everyone's responsibility
- not expecting to be able to fix it later. Some companies build without quality and then drop everything to “fix” quality later. This is a flawed approach as it leads to code cleanup being seen as a chore, hence, it often doesn't happen. Also, people often greatly overestimate their ability to fix quality issues later. As we are developing, we are also thinking about the domain and developing a contextual understanding about the problem we are solving. This contextual understanding is in large part what allows us to design and write quality code. If you move onto something else and then come back to it, that contextual understanding is largely lost and has to be regained by reviewing and reading the code. This takes time and effort and the difficulty of doing this is exacerbated if you need to look over multiple portions of the code at the same time.

Cleaning up technical debt and cruft is best done frequently. Larger issues can be raised under tasks, but in general the best way to remove technical debt and cruft is the boy scout rule which in the context of code means: leave the code a little better than when you found it. If every developer left the code base a little cleaner and a little better factored than when they found it, then the code base would be trending in a positive direction. This is a very important aspect of sustainable long-lived code bases. They get better over time rather than slowly atrophying over time because developers clean up little issues when they find them.

Following the boy scout rule or continual refactoring has an extra benefit as well. It improves the code in the places where the developers are making changes. This means that the code base gets better in places that have highest churn which is precisely where the risk is the highest. Changes are where bugs are introduced. It is also the part of the code that is least likely for those bugs to picked up as it hasn't yet been run in production by real users.
